# Problem 1: Multiples of 3 or 5

## Question
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.

## Explanation
This mathematical problem asks us to:

1. **Find Qualifying Numbers**
- Look for all numbers less than 1000
- Select numbers that are divisible by either 3 OR 5
- Include numbers divisible by both (like 15, 30, etc.) only once

2. **Example Demonstration (below 10)**
- Multiples of 3: 3, 6, 9
- Multiples of 5: 5
- Total sum: 3 + 5 + 6 + 9 = 23

3. **Main Task**
- Apply the same logic to numbers below 1000
- Find all numbers that are:
  - Multiples of 3 (3, 6, 9, ..., 999)
  - Multiples of 5 (5, 10, 15, ..., 995)
- Calculate their sum

The final answer should be a single number: 233168

```python
# Find the sum of all multiples of 3 or 5 below 1000
sum_multiples = 0
for i in range(1000):
    if i % 3 == 0 or i % 5 == 0:
        sum_multiples += i
print(sum_multiples)
```

OR

```python
# Find the sum of all multiples of 3 or 5 below 1000
sum_multiples = sum([i for i in range(1000) if i % 3 == 0 or i % 5 == 0])
print(sum_multiples)
```

---

# Problem 2: Even Fibonacci Numbers

## Question
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

## Explanation
This problem requires us to:

1. **Generate Fibonacci Sequence**
- Start with 1 and 2
- Each number is sum of previous two
- Continue until reaching 4 million
- Example sequence start: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...

2. **Filter Numbers**
- Only consider even numbers in the sequence
- Even numbers from start: 2, 8, 34, ...
- Stop when reaching 4 million

3. **Main Task**
- Generate Fibonacci numbers up to 4 million
- Select only even numbers
- Calculate their sum and print it

```python
# Function to find sum of even Fibonacci numbers up to 4 million
def even_fibonacci_sum(limit):
    # Initialize first two Fibonacci numbers
    a, b = 1, 2
    # Initialize sum to store even Fibonacci numbers
    total = 0
    
    # Continue loop until we reach the limit
    while a <= limit:
        # If current Fibonacci number is even, add it to total
        if a % 2 == 0:
            total += a
        
        # Generate next Fibonacci number
        # Store current 'b' in temp variable to calculate next number
        temp = b
        b = a + b  # Next number is sum of previous two
        a = temp   # Move 'b' to 'a' for next iteration
    
    return total

# Set limit to 4 million as per problem requirement
limit = int(input("Please enter the limit e.g. 4000000: "))
# Call function and print result
result = even_fibonacci_sum(limit)
print(f"Sum of even Fibonacci numbers not exceeding {limit}: {result}")
```

---

# Problem 3: Largest Prime Factor

## Question
The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143?

## Explanation
This problem requires us to:

1. **Understand Prime Factors**
- Prime factors are prime numbers that divide a number exactly
- Example demonstrated: 13195 = 5 × 7 × 13 × 29
- All these factors (5, 7, 13, 29) are prime numbers

2. **Main Task**
- Find all prime factors of 600851475143
- Identify the largest one among them
- The number is very large, requiring efficient computation

3. **Expected Output**
- A single number representing the largest prime factor
- Must be a prime number
- Will be the biggest among all prime factors

### Solution 1

```python
def largest_prime_factor(n):
    # Start with the smallest prime number
    i = 2

    # Keep dividing n by smaller numbers until i^2 > n
    while i * i <= n:
        if n % i:  # If n is not divisible by i
            i += 1  # Move to the next number
        else:  # If n is divisible by i
            n //= i  # Divide n by i and continue

    # If n is still greater than 1, it's the largest prime factor
    return n if n > 1 else i

# Test the function with a large number
number = 600851475143
result = largest_prime_factor(number)
print(f"Largest prime factor of {number} is: {result}")
```

### Step-by-Step Explanation:

1. **Initialize `i = 2`**:
   - Start with 2, the smallest prime number, to begin the factorization process.

2. **While loop**:
   - Continue the loop as long as \( i^2 \leq n \). This ensures we don't check unnecessary numbers.

3. **If `n % i`**:
   - If \( n \% i \neq 0 \), \( i \) is not a factor of \( n \), so increment \( i \) to check the next number.

4. **Else (`n % i == 0`)**:
   - If \( i \) divides \( n \), it's a factor.
   - Divide \( n \) by \( i \) using integer division (\( n = n // i \)) and repeat the process with the same \( i \), since \( n \) might still have more factors of \( i \).

5. **Final Result**:
   - When \( i^2 > n \), if \( n > 1 \), \( n \) itself is the largest prime factor.
   - If \( n = 1 \), \( i \) is the largest prime factor found during the loop.

---

### Example Walkthrough (for \( n = 13195 \)):

1. Start with \( n = 13195 \), \( i = 2 \):
   - \( 13195 \% 2 \neq 0 \), increment \( i \) to 3.
2. \( i = 3 \):
   - \( 13195 \% 3 \neq 0 \), increment \( i \) to 4.
3. \( i = 5 \):
   - \( 13195 \% 5 = 0 \), divide \( 13195 \) by 5: \( n = 2639 \).
4. Continue with \( i = 5 \):
   - \( 2639 \% 5 \neq 0 \), increment \( i \) to 6, 7, and so on.
5. \( i = 7 \):
   - \( 2639 \% 7 = 0 \), divide \( 2639 \) by 7: \( n = 377 \).
6. Continue dividing by factors (e.g., \( i = 13 \)), until \( n = 29 \).
7. Since \( 29 \) is prime and \( i^2 > n \), \( 29 \) is the largest prime factor.

---

### Output for \( 600851475143 \):
The largest prime factor of \( 600851475143 \) is **6857**.

### Solution 2

```python
def largest_prime_factor_optimized(n):
    largest_factor = 1
    
    # Handle all even factors first
    while n % 2 == 0:
        largest_factor = 2
        n = n // 2
    
    # Check only odd numbers up to square root
    for i in range(3, int(n ** 0.5) + 1, 2):
        while n % i == 0:
            largest_factor = i
            n = n // i
    
    # If n is still greater than 2, it's prime
    if n > 2:
        largest_factor = n
        
    return largest_factor

# Test the function
number = 600851475143
result = largest_prime_factor_optimized(number)
print(f"Largest prime factor of {number} is: {result}")
```
---

# Problem 4: Largest Palindrome Product

## Question
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
Find the largest palindrome made from the product of two 3-digit numbers.

## Explanation

1. **Understanding Palindromes**
- A palindrome reads the same forwards and backwards (like 9009)
- Example given: 9009 is palindrome (largest from 2-digit numbers)
- It's the product of 91 and 99

2. **Main Task**
- Find products of all 3-digit numbers (100 to 999)
- Check which products are palindromes
- Find the largest among these palindromes

3. **Expected Output**
- A single number that is:
  - A palindrome
  - Product of two 3-digit numbers
  - The largest such palindrome


### What is a palindrome?
A **palindrome** is a number (or word) that reads the same forwards and backwards. For example:
- 121 is a palindrome because if you read it from left to right or right to left, it’s the same number.
- 9009 is also a palindrome because if you reverse the digits, you still get 9009.

### The problem:
The task is to **find the largest palindromic number** that is the **product of two 3-digit numbers**. A 3-digit number is any number between 100 and 999 (like 100, 999, etc.).

For example, if you multiply two 3-digit numbers:
- \( 91 \times 99 = 9009 \)
9009 is a palindrome, and in the original problem, this was the largest palindrome from the product of two 2-digit numbers.

Now, we want to find the largest palindrome that is the product of two **3-digit numbers**.

### Breakdown of the steps to solve the problem:

1. **Multiply two 3-digit numbers**:
   - You will need to consider all combinations of two 3-digit numbers. The numbers go from 100 to 999.
   - So, you are multiplying numbers like \( 100 \times 100 \), \( 100 \times 101 \), \( 100 \times 102 \), and so on, up to \( 999 \times 999 \).
   
2. **Check if the product is a palindrome**:
   - After each multiplication, you check if the result is a palindrome. For example, if the result of multiplying two numbers is 9009, you check if 9009 reads the same forwards and backwards (it does, so it’s a palindrome).
   
3. **Keep track of the largest palindrome**:
   - While checking each product, you want to **keep track of the largest palindrome** you've found. If a new palindrome is larger than the previous largest one, update it.
   
4. **Stop when you've found all products**:
   - You'll eventually check all possible products of 3-digit numbers (from 100 to 999) and find the largest palindrome.

### Example to clarify:
Let’s work through an example manually to understand better:
- Consider two 3-digit numbers: 101 and 102.
- Multiply them:  
  \[
  101 \times 102 = 10302
  \]
- Check if 10302 is a palindrome: It’s **not**, because if you reverse the digits, you get 20301, which is not the same.
  
Let’s try another one:
- Take 101 and 103.
- Multiply them:  
  \[
  101 \times 103 = 10403
  \]
- Check if 10403 is a palindrome: It’s **not**, because reversing 10403 gives 30401, which is not the same.

You would continue doing this for all pairs of 3-digit numbers, and eventually, you’d find the largest palindrome, which, as the problem suggests, turns out to be **906609** (from \( 913 \times 993 \)).

### Final answer:
After running the code, the largest palindrome product of two 3-digit numbers is **906609**.

### Solution 1

```python
def is_palindrome(n):
    return str(n) == str(n)[::-1]

def find_largest_palindrome_simple():
    largest = 0
    # Check all combinations of 3-digit numbers
    for i in range(100, 1000):
        for j in range(100, 1000):
            product = i * j
            if is_palindrome(product) and product > largest:
                largest = product
    return largest

print(find_largest_palindrome_simple())
```

### Solution 2

```python
def find_largest_palindrome_optimized():
    largest = 0
    # Start from largest numbers for efficiency
    for i in range(999, 99, -1):
        # Start j from i to avoid duplicate calculations
        for j in range(i, 99, -1):
            product = i * j
            # Break inner loop if product becomes smaller than largest
            if product <= largest:
                break
            # Check palindrome
            if str(product) == str(product)[::-1]:
                largest = product
    return largest

print(find_largest_palindrome_optimized())
```
---

# Problem 5: Smallest Multiple

## Question
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

## Explanation

1. **Understanding the Problem**
- We need to find the least common multiple (LCM) of numbers 1 through 20
- Example given: 2520 is LCM of numbers 1 through 10
- The number must divide evenly (no remainder) by ALL numbers 1-20

2. **Main Task**
- Find a number that is divisible by all numbers from 1 to 20
- Must be the smallest such number
- Must give remainder 0 when divided by any number from 1 to 20

3. **Expected Output**
- A single positive integer
- Must be evenly divisible by all numbers 1-20
- Must be the smallest such number

### Solution 1:

```python
def is_divisible_by_all(n, max_divisor):
    for i in range(1, max_divisor + 1):
        if n % i != 0:
            return False
    return True

def find_smallest_multiple_simple():
    n = 1
    while True:
        if is_divisible_by_all(n, 20):
            return n
        n += 1

print(find_smallest_multiple_simple())
```

### Solution 2

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return abs(a * b) // gcd(a, b)

def find_smallest_multiple_optimized():
    result = 1
    for i in range(1, 21):
        result = lcm(result, i)
    return result

print(find_smallest_multiple_optimized())
```
---

# Problem 6: Sum Square Difference

## Question
The sum of the squares of the first ten natural numbers is 1² + 2² + ... + 10² = 385.
The square of the sum of the first ten natural numbers is (1 + 2 + ... + 10)² = 55² = 3025.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

## Explanation

1. **Understanding the Components**
- First calculation: Sum of squares (1² + 2² + ... + n²)
- Second calculation: Square of sum ((1 + 2 + ... + n)²)
- Example with n=10:
  - Sum of squares = 385
  - Square of sum = 3025
  - Difference = 3025 - 385 = 2640

2. **Main Task**
- Calculate both values for first 100 natural numbers
- Find sum of squares (1² + 2² + ... + 100²)
- Find square of sum (1 + 2 + ... + 100)²
- Calculate their difference

3. **Expected Output**
- A single number representing the difference
- Must be positive (larger minus smaller)

